# UnscrambleGame

## Описание игры
UnscrambleGame — это обучающая игра на Android, в которой игроку предстоит расшифровывать перемешанные слова из области разработки под Android (например, "kotlin", "compose", "viewmodel"). Игра состоит из 10 слов. За каждый правильный ответ начисляется 20 очков. При неправильном ответе отображается ошибка, а при пропуске — игра переходит к следующему слову без изменения счёта. По завершении всех вопросов показывается итоговый результат и предлагается сыграть снова.

## Технологии
- **Kotlin** — основной язык программирования
- **Jetpack Compose** — современный декларативный UI-фреймворк
- **ViewModel** — компонент архитектуры Android для управления состоянием UI
- **StateFlow** — реактивный поток данных для наблюдения за изменениями состояния

## Функциональность приложения
- Отображение случайно перемешанного слова
- Ввод предполагаемого ответа пользователем
- Проверка правильности ответа (с учётом регистра)
- Отображение ошибки при неверном ответе
- Возможность пропустить слово
- Автоматическое сохранение состояния при повороте экрана
- Подсчёт очков и отслеживание прогресса («Слово X из 10»)
- Диалог завершения игры с итоговым счётом и кнопкой «Играть снова»

---

## Контрольные вопросы

### 1. Что такое ViewModel и зачем он нужен?
**ViewModel** — это класс из библиотеки Android Jetpack, предназначенный для хранения и управления данными UI, связанными с жизненным циклом экрана (Activity/Fragment).  
Он решает проблему **потери состояния при изменении конфигурации** (например, при повороте экрана): без ViewModel все переменные в Activity или Composable-функциях сбрасываются, так как система уничтожает и заново создаёт Activity. ViewModel же переживает такие изменения и сохраняет данные до тех пор, пока экран активен.

### 2. В чём разница между MutableStateFlow и StateFlow?
- **MutableStateFlow** — изменяемая версия потока, позволяющая обновлять значение (`value = ...`).
- **StateFlow** — неизменяемый интерфейс, который можно только читать и наблюдать.

Поля `_uiState` (приватный `MutableStateFlow`) и `uiState` (публичный `StateFlow`) создаются по паттерну **"backing property"**: он обеспечивает инкапсуляцию — ViewModel может изменять состояние, а UI — только наблюдать за ним, что предотвращает неконтролируемые изменения извне.

### 3. Почему в ViewModel нельзя хранить Context или View?
ViewModel **не должен содержать ссылки на View, Activity или Context**, потому что он живёт дольше Activity при изменении конфигурации. Если сохранить ссылку на Activity, она не будет освобождена из памяти после её уничтожения, что вызовет **утечку памяти (memory leak)**.

### 4. Чем StateFlow отличается от remember и rememberSaveable?
| Подход | Переживает поворот? | Переживает смерть процесса? | Где хранится |
|--------|---------------------|------------------------------|--------------|
| `remember` | ❌ | ❌ | В Composable |
| `rememberSaveable` | ✅ | ✅ | В Bundle (ограничен простыми типами) |
| `StateFlow` (в ViewModel) | ✅ | ❌ | В памяти (до уничтожения ViewModel) |

- Используйте `remember` для временных, локальных состояний.
- `rememberSaveable` — когда нужно сохранить простые данные (строки, числа) при повороте.
- `StateFlow` + `ViewModel` — для сложной UI-логики и структурированного состояния.

### 5. Что такое data class в Kotlin и зачем он используется для UI State?
**data class** — специальный класс в Kotlin, предназначенный для хранения данных. Он автоматически генерирует:
- `equals()`, `hashCode()`, `toString()`
- метод `copy()` для создания изменённой копии объекта

Для UI State он идеален: позволяет хранить всё состояние экрана в одном месте, легко сравнивать состояния и безопасно обновлять их через `copy()` без мутации исходного объекта.

### 6. Как работает collectAsState() в Compose?
Функция `collectAsState()` **подписывается на StateFlow** и преобразует его в `State<T>`, который Compose может наблюдать. Когда значение в `StateFlow` меняется, Compose автоматически **перерисовывает** только те Composable-функции, которые зависят от этого состояния — благодаря механизму recomposition.

### 7. Зачем разделять код на пакеты data и ui?
Разделение кода на пакеты (`data`, `ui_model`, и т.д.) поддерживает принципы **чистой архитектуры** и **разделения ответственности (Separation of Concerns)**:
- `data` — содержит модели и константы (чистые данные)
- `ui_model` — содержит логику представления (ViewModel, Composables)

Это улучшает читаемость, тестируемость и масштабируемость проекта.

### 8. Что происходит с ViewModel при полном закрытии приложения (process death)?
При **смерти процесса** (например, система убивает приложение из-за нехватки памяти) **ViewModel уничтожается**, и все его данные теряются.  
Для долговременного хранения данных следует использовать:
- **Room / SQLite** — для структурированных данных
- **DataStore / SharedPreferences** — для небольших настроек
- **Файловую систему или сеть** — при необходимости

ViewModel предназначен только для **временного хранения UI-состояния**, а не для постоянного сохранения.

---
## Автор

**ФИО**: Алексеев Григорий Сергеевич
**Группа**: ИСП-232